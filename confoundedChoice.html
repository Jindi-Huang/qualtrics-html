<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Confounded Choice</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; padding: 0; background: #ffffff; }
    @keyframes coinPop {
      0% { transform: translateY(0) scale(1); opacity: 1; }
      50% { transform: translateY(-50px) scale(1.2); opacity: 1; }
      100% { transform: translateY(-70px) scale(0.8); opacity: 0; }
    }
    @keyframes coinSpin {
      0% { transform: scaleX(1); }
      25% { transform: scaleX(0.3); }
      50% { transform: scaleX(1); }
      75% { transform: scaleX(0.3); }
      100% { transform: scaleX(1); }
    }
    @keyframes coinHover {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-6px); }
    }
    @keyframes fadeIn {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script>
    // =============== QUALTRICS COMMUNICATION ===============
    let participantId = null;
    let gameId = null;

    // Receive config from Qualtrics
    window.addEventListener('message', function(event) {
      if (event.data.type === 'INIT') {
        console.log('Received INIT from Qualtrics:', event.data);
        participantId = event.data.participantId;
        gameId = event.data.gameId;

        if (event.data.gameConfig) {
          const qConfig = event.data.gameConfig;
          if (qConfig.nRounds !== undefined) CONFIG.totalRounds = parseInt(qConfig.nRounds) || CONFIG.totalRounds;
          if (qConfig.id) CONFIG.id = qConfig.id;
          if (qConfig.yBonus !== undefined) CONFIG.noHeadachePayoff = qConfig.yBonus;
          if (qConfig.yCost !== undefined) CONFIG.headachePayoff = qConfig.yCost;
          if (qConfig.aCost0 !== undefined) CONFIG.aCost0 = qConfig.aCost0;
          if (qConfig.aCost1 !== undefined) CONFIG.aCost1 = qConfig.aCost1;
          if (qConfig.drinkName) CONFIG.drinkName = qConfig.drinkName;
          if (qConfig.playerName0) CONFIG.playerName0 = qConfig.playerName0;
          if (qConfig.playerIcon0) CONFIG.playerIcon0 = qConfig.playerIcon0;
          if (qConfig.playerName2) CONFIG.playerName2 = qConfig.playerName2;
          if (qConfig.playerName2Pos) CONFIG.playerName2Pos = qConfig.playerName2Pos;
          if (qConfig.playerName2Neg) CONFIG.playerName2Neg = qConfig.playerName2Neg;
          // DGP parameters: Y (feeling good) independent, X (craving) depends on Y
          if (qConfig.pY !== undefined) CONFIG.confounder.pY = qConfig.pY;
          if (qConfig.pX_Y !== undefined) CONFIG.confounder.pX_Y = qConfig.pX_Y;  // P(craving | feeling good) = 0.85
          if (qConfig.pX_y !== undefined) CONFIG.confounder.pX_y = qConfig.pX_y;  // P(craving | feeling bad) = 0.15
          console.log('Applied config:', CONFIG);
        }

        // Mark as initialized and trigger callbacks
        markInitialized();

        sendDataToQualtrics('GAME_START', { started: true });
      }
    });

    // Send data to Qualtrics
    function sendDataToQualtrics(dataType, data) {
      if (window.parent !== window) {
        window.parent.postMessage({
          type: 'GAME_DATA',
          gameId: gameId,
          dataType: dataType,
          data: data,
          participantId: participantId,
          timestamp: new Date().toISOString()
        }, '*');
      }
      console.log('Sent to Qualtrics:', dataType, data);
    }

    // Configuration
    const CONFIG = {
      noHeadachePayoff: 2.00,
      headachePayoff: -2.00,
      totalRounds: 10,
      currency: '$',
      id: 1,
      aCost0: 1.00,   // cost of drinking when no craving (positive = pay)
      aCost1: -1.00,  // cost of drinking when craving (negative = receive)

      // DGP: Y (feeling good) generated independently, X (craving) depends on Y
      // Display order: X (craving) shown first ‚Üí A (action) ‚Üí Y (feeling) revealed
      confounder: {
        pY: 0.50,      // P(Y=1) - probability of feeling good
        pX_Y: 0.85,    // P(X=1 | Y=1) - probability of craving given feeling good
        pX_y: 0.15,    // P(X=1 | Y=0) - probability of craving given feeling bad
      },

      drinkName: 'Driftwell',
      playerName0: 'Driftwell',   // Drink name (A)
      playerIcon0: 'ü•§',          // Icon for drink action (A)
      playerName2: 'Feeling',     // Outcome name (X)
      playerName2Pos: 'good',     // Positive outcome (X=0, no headache)
      playerName2Neg: 'bad',      // Negative outcome (X=1, headache)
    };
  </script>

  <script type="text/babel">
    const { useState, useCallback, useEffect, useRef } = React;

    // Track if config has been received from Qualtrics
    let isInitialized = false;
    let initCallbacks = [];

    function onInitialized(callback) {
      if (isInitialized) {
        callback();
      } else {
        initCallbacks.push(callback);
      }
    }

    function markInitialized() {
      isInitialized = true;
      initCallbacks.forEach(cb => cb());
      initCallbacks = [];
    }

    // Generate round outcomes: Y (feeling good) independent, X (craving) depends on Y
    // Display order: X (craving) shown first ‚Üí A (action) ‚Üí Y (feeling) revealed
    function generateRound() {
      const { pY, pX_Y, pX_y } = CONFIG.confounder;
      // Y = feeling good (generated independently)
      const Y = Math.random() < pY ? 1 : 0;
      // X = craving (depends on Y)
      const pX = [pX_y, pX_Y];  // pX[0] = P(X=1|Y=0) = P(craving|bad), pX[1] = P(X=1|Y=1) = P(craving|good)
      const X = Math.random() < pX[Y] ? 1 : 0;
      return {
        craving: X === 1,
        noHeadache: Y === 1  // Y=1 means feeling good
      };
    }

    // Statistics calculator
    function calculateStats(history) {
      const stats = {
        drinkYes: { total: 0, noHeadache: 0 },
        drinkNo: { total: 0, noHeadache: 0 },
        cravingYes: { total: 0, noHeadache: 0, drank: 0 },
        cravingNo: { total: 0, noHeadache: 0, drank: 0 },
      };
      
      history.forEach(round => {
        if (round.drank) {
          stats.drinkYes.total++;
          if (round.noHeadache) stats.drinkYes.noHeadache++;
        } else {
          stats.drinkNo.total++;
          if (round.noHeadache) stats.drinkNo.noHeadache++;
        }
        
        if (round.craving) {
          stats.cravingYes.total++;
          if (round.noHeadache) stats.cravingYes.noHeadache++;
          if (round.drank) stats.cravingYes.drank++;
        } else {
          stats.cravingNo.total++;
          if (round.noHeadache) stats.cravingNo.noHeadache++;
          if (round.drank) stats.cravingNo.drank++;
        }
      });
      
      return stats;
    }

    // Craving indicator
    function CravingIndicator({ craving }) {
      return (
        <div className="flex flex-col items-center">
          <div className="w-12 h-12 rounded-full flex items-center justify-center transition-all duration-500 bg-gray-200">
            <span className={`text-2xl transition-all duration-300 ${craving === null ? 'grayscale opacity-30' : ''}`}>
              {craving === null ? '‚ùì' : craving ? 'ü§§' : 'üòê'}
            </span>
          </div>
          <div className="text-sm font-medium text-gray-700 mt-1">
            {craving === null ? 'Checking...' : craving ? 'Craving!' : 'No Craving'}
          </div>
        </div>
      );
    }

    // Helper to capitalize first letter
    function capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }

    // Outcome indicator
    function OutcomeIndicator({ noHeadache }) {
      return (
        <div className="flex flex-col items-center mt-8">
          <div className={`w-28 h-28 rounded-full flex items-center justify-center transition-all duration-500 ${
            noHeadache === null ? 'bg-gray-200' : noHeadache ? 'bg-gradient-to-br from-emerald-400 to-green-600' : 'bg-gradient-to-br from-rose-400 to-red-600'
          }`}>
            <span className={`text-6xl transition-all duration-300 ${noHeadache === null ? 'grayscale opacity-30' : ''}`}>
              {noHeadache === null ? 'üò∂' : noHeadache ? 'üòä' : 'üòî'}
            </span>
          </div>
          <div className="text-lg font-bold text-gray-700 mt-2">
            {noHeadache === null ? 'Later this day...' : noHeadache ? `${capitalize(CONFIG.playerName2Pos)}!` : capitalize(CONFIG.playerName2Neg)}
          </div>
          <div className={`text-lg font-bold mt-1 ${noHeadache === null || !noHeadache ? 'invisible' : 'text-green-600'}`}>
            {noHeadache ? `+${CONFIG.currency}${CONFIG.noHeadachePayoff.toFixed(0)}` : '\u00A0'}
          </div>
        </div>
      );
    }

    // New Week overlay
    function NewDayOverlay({ show, dayNumber }) {
      if (!show) return null;

      return (
        <div className="absolute inset-0 bg-white/95 flex items-center justify-center z-10 rounded-2xl">
          <div className="text-center">
            <div className="text-6xl mb-4">üåÖ</div>
            <div className="text-3xl font-bold text-gray-800">New Week</div>
            <div className="text-xl text-gray-500 mt-2">Week {dayNumber}</div>
          </div>
        </div>
      );
    }

    // Mario-style spinning coin
    function MarioCoin({ show }) {
      if (!show) return null;
      
      return (
        <div className="absolute -top-4 left-1/2 -translate-x-1/2 pointer-events-none">
          <div style={{ animation: 'coinPop 0.8s ease-out forwards' }}>
            <div style={{ animation: 'coinSpin 0.15s linear infinite' }}>
              ü™ô
            </div>
          </div>
        </div>
      );
    }

    // Static coin hovering above button
    function HoveringCoin({ show, fading }) {
      if (!show) return null;
      
      return (
        <div className={`absolute -top-10 left-1/2 -translate-x-1/2 pointer-events-none transition-opacity duration-500 ${
          fading ? 'opacity-0' : 'opacity-100'
        }`}>
          <div className="text-3xl" style={{ animation: 'coinHover 1s ease-in-out infinite' }}>
            ü™ô
          </div>
        </div>
      );
    }

    // Drink ‚Üí Good correlation
    function DrinkHeadacheCorrelation({ stats, currentDrank }) {
      const drinkGoodRate = stats.drinkYes.total > 0
        ? Math.round((stats.drinkYes.noHeadache / stats.drinkYes.total) * 100)
        : null;
      const skipGoodRate = stats.drinkNo.total > 0
        ? Math.round((stats.drinkNo.noHeadache / stats.drinkNo.total) * 100)
        : null;

      const diff = (drinkGoodRate !== null && skipGoodRate !== null)
        ? drinkGoodRate - skipGoodRate
        : null;

      return (
        <div className="bg-white rounded-2xl p-5 border-2 border-blue-200 shadow-sm">
          <h3 className="text-blue-600 font-bold text-lg mb-4 flex items-center gap-2">
            <span className="text-2xl">üìä</span> {CONFIG.playerName0} ‚á¢ {capitalize(CONFIG.playerName2Pos)}
          </h3>

          <div className="grid grid-cols-2 gap-4">
            <div className={`rounded-xl p-4 transition-all duration-300 ${
              currentDrank === true ? 'bg-green-50 ring-2 ring-green-400' : 'bg-gray-50'
            }`}>
              <div className="flex items-center gap-2 mb-2">
                <span className="text-xl">{CONFIG.playerIcon0}</span>
                <span className="text-green-600 font-medium">{CONFIG.playerName0}</span>
              </div>
              <div className="text-4xl font-bold text-gray-900 mb-1">
                {drinkGoodRate !== null ? `${drinkGoodRate}%` : '‚Äî'}
              </div>
              <div className="text-sm text-gray-500">
                {CONFIG.playerName2Pos} ({stats.drinkYes.noHeadache}/{stats.drinkYes.total})
              </div>
              <div className="mt-3 h-3 bg-gray-200 rounded-full overflow-hidden">
                <div
                  className="h-full bg-gradient-to-r from-green-500 to-emerald-400 transition-all duration-500"
                  style={{ width: drinkGoodRate ? `${drinkGoodRate}%` : '0%' }}
                />
              </div>
            </div>

            <div className={`rounded-xl p-4 transition-all duration-300 ${
              currentDrank === false ? 'bg-red-50 ring-2 ring-red-400' : 'bg-gray-50'
            }`}>
              <div className="flex items-center gap-2 mb-2">
                <span className="text-xl">‚äò</span>
                <span className="text-red-600 font-medium">Skip</span>
              </div>
              <div className="text-4xl font-bold text-gray-900 mb-1">
                {skipGoodRate !== null ? `${skipGoodRate}%` : '‚Äî'}
              </div>
              <div className="text-sm text-gray-500">
                {CONFIG.playerName2Pos} ({stats.drinkNo.noHeadache}/{stats.drinkNo.total})
              </div>
              <div className="mt-3 h-3 bg-gray-200 rounded-full overflow-hidden">
                <div
                  className="h-full bg-gradient-to-r from-red-500 to-rose-400 transition-all duration-500"
                  style={{ width: skipGoodRate ? `${skipGoodRate}%` : '0%' }}
                />
              </div>
            </div>
          </div>

          {diff !== null && (
            <div className="mt-4 bg-blue-50 rounded-lg p-3 border border-blue-200">
              <div className="text-center">
                <span className="text-blue-600 text-sm">Difference: </span>
                <span className="text-gray-900 font-bold text-xl">
                  {diff > 0 ? '+' : ''}{diff}%
                </span>
                <span className="text-gray-500 text-sm"> more likely to feel {CONFIG.playerName2Pos} when drinking {CONFIG.playerName0}</span>
              </div>
            </div>
          )}
        </div>
      );
    }

    // Craving stats panel with 4 quadrants
    function CravingStatsPanel({ stats, currentCraving }) {
      // Row 1: Craving ‚Üí Drink
      const cravingDrinkRate = stats.cravingYes.total > 0
        ? Math.round(stats.cravingYes.drank / stats.cravingYes.total * 100)
        : null;
      const noCravingDrinkRate = stats.cravingNo.total > 0
        ? Math.round(stats.cravingNo.drank / stats.cravingNo.total * 100)
        : null;

      // Row 2: Craving ‚Üí Feeling Good
      const cravingGoodRate = stats.cravingYes.total > 0
        ? Math.round(stats.cravingYes.noHeadache / stats.cravingYes.total * 100)
        : null;
      const noCravingGoodRate = stats.cravingNo.total > 0
        ? Math.round(stats.cravingNo.noHeadache / stats.cravingNo.total * 100)
        : null;

      return (
        <div className="bg-white rounded-xl p-4 border border-gray-200 shadow-sm">
          <h4 className="text-gray-500 text-sm font-medium mb-3 text-center">Craving Statistics</h4>

          <div className="space-y-2">
            {/* Row 1: Craving ‚Üí Drink */}
            <div className="grid grid-cols-2 gap-2 text-xs">
              <div className="bg-gray-50 rounded p-2 text-center border border-gray-200">
                <div className="text-purple-600">Craving ‚á¢ {CONFIG.playerName0}</div>
                <div className="text-gray-900 font-bold">
                  {cravingDrinkRate !== null ? `${cravingDrinkRate}% drank` : '‚Äî'}
                </div>
              </div>
              <div className="bg-gray-50 rounded p-2 text-center border border-gray-200">
                <div className="text-gray-600">No Craving ‚á¢ {CONFIG.playerName0}</div>
                <div className="text-gray-900 font-bold">
                  {noCravingDrinkRate !== null ? `${noCravingDrinkRate}% drank` : '‚Äî'}
                </div>
              </div>
            </div>

            {/* Row 2: Craving ‚Üí Feeling */}
            <div className="grid grid-cols-2 gap-2 text-xs">
              <div className="bg-gray-50 rounded p-2 text-center border border-gray-200">
                <div className="text-purple-600">Craving ‚á¢ {capitalize(CONFIG.playerName2Pos)}</div>
                <div className="text-gray-900 font-bold">
                  {cravingGoodRate !== null ? `${cravingGoodRate}%` : '‚Äî'}
                </div>
              </div>
              <div className="bg-gray-50 rounded p-2 text-center border border-gray-200">
                <div className="text-gray-600">No Craving ‚á¢ {capitalize(CONFIG.playerName2Pos)}</div>
                <div className="text-gray-900 font-bold">
                  {noCravingGoodRate !== null ? `${noCravingGoodRate}%` : '‚Äî'}
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    }

    // Drink decision panel
    function DrinkDecisionPanel({ onChoice, disabled, craving, selected, showCoinAnimation, coinFading }) {
      const showHoveringCoin = craving && (selected === null || coinFading) && !showCoinAnimation;

      return (
        <div className="flex flex-col items-center">
          <div className="flex justify-center gap-4 relative">
            <div className="relative">
              <HoveringCoin show={showHoveringCoin} fading={coinFading} />
              <MarioCoin show={showCoinAnimation} />
              <button
                onClick={() => onChoice(true)}
                disabled={disabled}
                className={`w-32 h-20 px-4 py-3 rounded-lg font-bold transition-all flex items-center justify-center gap-2 cursor-pointer ${
                  disabled
                    ? selected === true
                      ? 'bg-blue-600 text-white'
                      : 'bg-gray-200 text-gray-400 cursor-not-allowed'
                    : craving
                      ? 'bg-blue-600 hover:bg-blue-500 text-white shadow-lg hover:shadow-xl ring-2 ring-yellow-400'
                      : 'bg-blue-600 hover:bg-blue-500 text-white shadow-lg hover:shadow-xl'
                }`}
              >
                <span className="text-xl">ü•§</span>
                <div className="text-left">
                  <div>Drink</div>
                  <div>{CONFIG.drinkName}</div>
                  <div className="text-xs opacity-70">{craving ? `+${CONFIG.currency}${Math.abs(CONFIG.aCost1).toFixed(2)}` : `-${CONFIG.currency}${Math.abs(CONFIG.aCost0).toFixed(2)}`}</div>
                </div>
              </button>
            </div>

            <button
              onClick={() => onChoice(false)}
              disabled={disabled}
              className={`w-32 h-20 px-4 py-3 rounded-lg font-bold transition-all flex flex-col items-center justify-center cursor-pointer ${
                disabled
                  ? selected === false
                    ? 'bg-blue-600 text-white'
                    : 'bg-gray-200 text-gray-400 cursor-not-allowed'
                  : 'bg-blue-600 hover:bg-blue-500 text-white shadow-lg hover:shadow-xl'
              }`}
            >
              <div className="flex items-center gap-2">
                <span className="text-xl">‚äò</span>
                <span>Skip</span>
              </div>
              <div className="text-xs opacity-70">{CONFIG.currency}0</div>
            </button>
          </div>
        </div>
      );
    }

    // Scrollable history
    function ScrollableHistory({ history }) {
      const allRounds = history.slice().reverse();

      return (
        <div className="bg-white rounded-xl p-4 border border-gray-200 shadow-sm h-full flex flex-col">
          <h4 className="text-gray-500 text-sm font-medium mb-3">All Weeks</h4>
          <div className="space-y-1 flex-1 overflow-y-auto">
            {allRounds.map((round) => (
              <div key={round.roundNumber} className="flex items-center gap-2 text-sm py-1 px-2 bg-gray-50 rounded border border-gray-100">
                <span className="text-gray-400 w-6">#{round.roundNumber}</span>
                <span className={`w-8 ${round.craving ? 'text-purple-600' : 'text-gray-400'}`}>
                  {round.craving ? 'ü§§' : 'üòê'}
                </span>
                <span className={`flex-1 font-medium text-center ${round.drank ? 'text-blue-600' : 'text-gray-400'}`}>
                  {round.drank ? CONFIG.playerIcon0 : '‚äò'}
                </span>
                <span className={`text-2xl w-10 h-10 flex items-center justify-center rounded-lg ${
                  round.noHeadache ? 'bg-green-600' : 'bg-red-600'
                }`}>
                  {round.noHeadache ? 'üòä' : 'üòî'}
                </span>
              </div>
            ))}
            {history.length === 0 && (
              <p className="text-gray-400 text-center py-4">No weeks yet</p>
            )}
          </div>
        </div>
      );
    }

    // DAG Iframe Component
    function DAGIframe({ onComplete, playerName0, playerIcon0, nRounds }) {
      const iframeRef = useRef(null);

      useEffect(() => {
        const handleMessage = (event) => {
          if (event.data.type === 'DAG_DATA' && event.data.dataType === 'DAG_COMPLETE') {
            const data = event.data.data;
            onComplete(data.initialDAG, data.finalDAG, data.confidence, data.DAGAlertCount, data.initialDAGTime, data.finalDAGTime, data.confidenceTime);
          }
        };

        window.addEventListener('message', handleMessage);

        // Send INIT to iframe once loaded
        const sendInit = () => {
          if (iframeRef.current && iframeRef.current.contentWindow) {
            iframeRef.current.contentWindow.postMessage({
              type: 'INIT',
              gameConfig: {
                playerName0: playerName0,
                playerName1: 'Craving',
                playerIcon0: playerIcon0,
                nRounds: nRounds
              }
            }, '*');
          }
        };

        // Try sending after a short delay to ensure iframe is loaded
        const timeout = setTimeout(sendInit, 500);

        return () => {
          window.removeEventListener('message', handleMessage);
          clearTimeout(timeout);
        };
      }, [onComplete, playerName0, playerIcon0, nRounds]);

      return (
        <iframe
          ref={iframeRef}
          src="dagElicitationV2.html"
          style={{ width: '100%', height: '100vh', border: 'none' }}
          onLoad={() => {
            if (iframeRef.current && iframeRef.current.contentWindow) {
              iframeRef.current.contentWindow.postMessage({
                type: 'INIT',
                gameConfig: {
                  playerName0: playerName0,
                  playerName1: 'Craving',
                  playerIcon0: playerIcon0,
                  nRounds: nRounds
                }
              }, '*');
            }
          }}
        />
      );
    }

    // Main experiment component
    function CravingExperiment() {
      const [ready, setReady] = useState(false);
      const [currentRound, setCurrentRound] = useState(1);
      const [phase, setPhase] = useState('craving');
      const [history, setHistory] = useState([]);
      const [currentCraving, setCurrentCraving] = useState(null);
      const [pendingOutcome, setPendingOutcome] = useState(null);  // Y (feeling) determined upfront but revealed later
      const [currentDrank, setCurrentDrank] = useState(null);
      const [currentOutcome, setCurrentOutcome] = useState(null);
      const [showCoinAnimation, setShowCoinAnimation] = useState(false);
      const [coinFading, setCoinFading] = useState(false);
      const [showNewDay, setShowNewDay] = useState(false);
      const [nextDayNumber, setNextDayNumber] = useState(2);
      const [totalEarnings, setTotalEarnings] = useState(0);
      const [selectedPaymentRound, setSelectedPaymentRound] = useState(null);

      // DAG-related state
      const [showDAG, setShowDAG] = useState(false);
      const [dagCompleted, setDagCompleted] = useState(false);
      const [dagData, setDagData] = useState({ initial: null, final: null, confidence: null, alertCount: null });

      const roundTimesRef = useRef([]);
      const roundStartTimeRef = useRef(Date.now());
      const dataSentRef = useRef(false);
      const halfwayDAGShownRef = useRef(false);

      // Wait for Qualtrics config before showing game (max 3 seconds)
      useEffect(() => {
        const timeout = setTimeout(() => {
          if (!ready) {
            console.log('Timeout: starting with default config');
            setReady(true);
            roundStartTimeRef.current = Date.now();
          }
        }, 3000);

        onInitialized(() => {
          clearTimeout(timeout);
          setReady(true);
          roundStartTimeRef.current = Date.now();
        });

        return () => clearTimeout(timeout);
      }, []);

      const stats = calculateStats(history);

      const startRound = useCallback(() => {
        // Generate both X (craving) and Y (feeling) upfront
        // Y is independent, X depends on Y
        // Display: show X (craving) first, reveal Y (feeling) after action
        const round = generateRound();
        setCurrentCraving(round.craving);
        setPendingOutcome(round.noHeadache);  // Store Y to reveal later
        setPhase('decision');
      }, []);

      useEffect(() => {
        if (ready && phase === 'craving' && currentCraving === null) {
          // Generate craving immediately when ready
          const round = generateRound();
          setCurrentCraving(round.craving);
          setPendingOutcome(round.noHeadache);
          setPhase('decision');
        }
      }, [ready, phase, currentCraving]);
      
      const handleChoice = useCallback((drank) => {
        roundTimesRef.current.push((Date.now() - roundStartTimeRef.current) / 1000);

        setCurrentDrank(drank);

        if (currentCraving) {
          if (drank) {
            setShowCoinAnimation(true);
            setTimeout(() => setShowCoinAnimation(false), 800);
          } else {
            setCoinFading(true);
            setTimeout(() => setCoinFading(false), 500);
          }
        }

        setPhase('outcome');

        // Reveal the pre-determined outcome (Y was generated in startRound)
        setTimeout(() => {
          setCurrentOutcome(pendingOutcome);

          const headacheEarnings = pendingOutcome ? CONFIG.noHeadachePayoff : CONFIG.headachePayoff;
          const drinkCost = drank ? (currentCraving ? CONFIG.aCost1 : CONFIG.aCost0) : 0;
          const drinkEarnings = -drinkCost; // negative cost = positive earnings
          const earnings = headacheEarnings + drinkEarnings;

          const roundData = {
            roundNumber: currentRound,
            craving: currentCraving,
            drank: drank,
            noHeadache: pendingOutcome,
            earnings: earnings,
          };

          setHistory(prev => [...prev, roundData]);
          setTotalEarnings(prev => prev + earnings);
          
          if (currentRound >= CONFIG.totalRounds) {
            setTimeout(() => {
              const paymentRound = Math.floor(Math.random() * CONFIG.totalRounds) + 1;
              setSelectedPaymentRound(paymentRound);
              setPhase('complete');
            }, 2000);
          } else {
            // Check if we're at the halfway point and haven't shown DAG yet
            const halfwayPoint = Math.floor(CONFIG.totalRounds / 2);
            if (currentRound === halfwayPoint && !halfwayDAGShownRef.current) {
              halfwayDAGShownRef.current = true;
              setTimeout(() => {
                setShowDAG(true);
              }, 1500);
            } else {
              setTimeout(() => {
                // Show overlay immediately
                setNextDayNumber(currentRound + 1);
                setShowNewDay(true);

                // Reset values and generate new round while overlay is covering
                setTimeout(() => {
                  setCurrentDrank(null);
                  setCurrentOutcome(null);
                  setCoinFading(false);
                  setCurrentRound(prev => prev + 1);
                  setPhase('decision');
                  roundStartTimeRef.current = Date.now();
                  // Generate new craving/outcome while overlay is still visible
                  const round = generateRound();
                  setCurrentCraving(round.craving);
                  setPendingOutcome(round.noHeadache);
                }, 200);

                // Hide overlay after values are set
                setTimeout(() => {
                  setShowNewDay(false);
                }, 1200);
              }, 1500);
            }
          }
        }, 800);
      }, [currentRound, currentCraving, pendingOutcome]);

      // Handle DAG completion
      const handleDAGComplete = useCallback((initialDAG, finalDAG, confidence, DAGAlertCount, initialDAGTime, finalDAGTime, confidenceTime) => {
        setDagData({ initial: initialDAG, final: finalDAG, confidence: confidence, alertCount: DAGAlertCount, initialDAGTime, finalDAGTime, confidenceTime });
        setDagCompleted(true);
        setShowDAG(false);

        // Send DAG data to Qualtrics
        sendDataToQualtrics('DAG_DATA', {
          initialDAG: initialDAG,
          finalDAG: finalDAG,
          confidence: confidence,
          DAGAlertCount: DAGAlertCount,
          initialDAGTime: initialDAGTime,
          finalDAGTime: finalDAGTime,
          confidenceTime: confidenceTime,
          completedAtRound: currentRound
        });

        // Continue to next round
        setTimeout(() => {
          setNextDayNumber(currentRound + 1);

          setTimeout(() => {
            setShowNewDay(true);

            setTimeout(() => {
              setShowNewDay(false);
              setCurrentRound(prev => prev + 1);
              setPhase('decision');
              setCurrentDrank(null);
              setCurrentOutcome(null);
              setCoinFading(false);
              roundStartTimeRef.current = Date.now();
              // Generate new craving/outcome
              const round = generateRound();
              setCurrentCraving(round.craving);
              setPendingOutcome(round.noHeadache);
            }, 1000);
          }, 100);
        }, 500);
      }, [currentRound]);

      // Show loading screen while waiting for Qualtrics config
      if (!ready) {
        return (
          <div className="min-h-screen bg-white flex items-center justify-center">
            <div className="text-gray-700 text-xl">Loading...</div>
          </div>
        );
      }

      // Send final data when game completes
      if (phase === 'complete' && history.length === CONFIG.totalRounds && !dataSentRef.current) {
        dataSentRef.current = true;

        sendDataToQualtrics('FINAL_DATA', {
          history: history.map(r => ({
            craving: r.craving ? 1 : 0,
            drank: r.drank ? 1 : 0,
            noHeadache: r.noHeadache ? 1 : 0,
            earnings: r.earnings
          })),
          roundTimes: roundTimesRef.current,
          selectedPaymentRound: selectedPaymentRound,
          totalEarnings: totalEarnings,
          dagInitial: dagData.initial,
          dagFinal: dagData.final,
          dagConfidence: dagData.confidence,
          DAGAlertCount: dagData.alertCount,
          initialDAGTime: dagData.initialDAGTime,
          finalDAGTime: dagData.finalDAGTime,
          confidenceTime: dagData.confidenceTime
        });

        setTimeout(() => {
          sendDataToQualtrics('GAME_COMPLETE', { completed: true });
        }, 500);
      }

      // Show DAG drawing interface (loads from separate file)
      if (showDAG) {
        return (
          <DAGIframe
            onComplete={handleDAGComplete}
            playerName0={CONFIG.playerName0}
            playerIcon0={CONFIG.playerIcon0}
            nRounds={CONFIG.totalRounds}
          />
        );
      }

      // Complete screen
      if (phase === 'complete') {
        const paymentRoundData = history[selectedPaymentRound - 1];
        const drinkGoodRate = stats.drinkYes.total > 0
          ? Math.round(stats.drinkYes.noHeadache / stats.drinkYes.total * 100)
          : 0;
        const skipGoodRate = stats.drinkNo.total > 0
          ? Math.round(stats.drinkNo.noHeadache / stats.drinkNo.total * 100)
          : 0;
        const cravingGoodRate = stats.cravingYes.total > 0
          ? Math.round(stats.cravingYes.noHeadache / stats.cravingYes.total * 100)
          : 0;
        const noCravingGoodRate = stats.cravingNo.total > 0
          ? Math.round(stats.cravingNo.noHeadache / stats.cravingNo.total * 100)
          : 0;

        return (
          <div className="min-h-screen bg-white flex items-center justify-center p-4">
            <div className="bg-white rounded-2xl shadow-2xl p-8 max-w-xl w-full border border-gray-200">
              <div className="text-center">
                <div className="text-6xl mb-4">üéâ</div>
                <h1 className="text-3xl font-bold text-gray-800 mb-2">Experiment Complete!</h1>
                <p className="text-gray-600 mb-6">All {CONFIG.totalRounds} weeks finished.</p>
              </div>

              <div className="bg-gradient-to-r from-blue-500 to-cyan-600 rounded-xl p-5 text-white mb-4">
                <h3 className="font-bold mb-3 text-lg">üìä {CONFIG.playerName0} ‚á¢ {capitalize(CONFIG.playerName2Pos)}</h3>
                <div className="grid grid-cols-2 gap-4">
                  <div className="bg-white/20 rounded-lg p-3">
                    <div className="text-sm">{CONFIG.playerName0}</div>
                    <div className="text-3xl font-bold">{drinkGoodRate}%</div>
                    <div className="text-xs opacity-80">{CONFIG.playerName2Pos}</div>
                  </div>
                  <div className="bg-white/20 rounded-lg p-3">
                    <div className="text-sm">Skip</div>
                    <div className="text-3xl font-bold">{skipGoodRate}%</div>
                    <div className="text-xs opacity-80">{CONFIG.playerName2Pos}</div>
                  </div>
                </div>
                <div className="mt-3 text-center text-sm">
                  Difference: <span className="font-bold text-lg">{drinkGoodRate - skipGoodRate > 0 ? '+' : ''}{drinkGoodRate - skipGoodRate}%</span>
                </div>
              </div>

              <div className="bg-gray-100 rounded-lg p-3 mb-4">
                <h3 className="font-medium mb-2 text-gray-600 text-sm">ü§§ Craving ‚á¢ {capitalize(CONFIG.playerName2Pos)}</h3>
                <div className="flex justify-center gap-6 text-sm">
                  <div className="text-center">
                    <div className="text-gray-500">Craving</div>
                    <div className="text-xl font-bold text-gray-800">{cravingGoodRate}%</div>
                  </div>
                  <div className="text-center">
                    <div className="text-gray-500">No Craving</div>
                    <div className="text-xl font-bold text-gray-800">{noCravingGoodRate}%</div>
                  </div>
                </div>
              </div>

              <div className="bg-emerald-50 border-2 border-emerald-200 rounded-xl p-5">
                <p className="text-sm text-emerald-600 mb-1">Payment Week #{selectedPaymentRound}</p>
                <div className="text-sm text-emerald-700 mb-2">
                  {paymentRoundData.craving ? 'ü§§ Craving' : 'üòê No Craving'} ‚Üí
                  {paymentRoundData.drank ? ' ü•§ Drank' : ' ‚äò Skipped'} ‚Üí
                  {paymentRoundData.noHeadache ? ` üòä ${capitalize(CONFIG.playerName2Pos)}` : ` üòî ${capitalize(CONFIG.playerName2Neg)}`}
                </div>
                <p className="text-3xl font-bold text-emerald-800">
                  {paymentRoundData.earnings >= 0 ? '+' : ''}{CONFIG.currency}{paymentRoundData.earnings.toFixed(2)}
                </p>
              </div>
            </div>
          </div>
        );
      }
      
      return (
        <div className="min-h-screen bg-white px-4 pt-0 pb-4">
          <div className="max-w-6xl mx-auto">
            <div className="bg-gray-50 rounded-2xl p-6 mb-4 border border-gray-200 shadow-sm relative overflow-hidden">
              <NewDayOverlay show={showNewDay} dayNumber={nextDayNumber} />

              <div className="text-center mb-4">
                <span className={`inline-block px-4 py-2 rounded-full text-sm font-medium ${
                  phase === 'outcome' && currentOutcome !== null
                    ? (currentOutcome ? 'bg-green-50 text-green-700 border border-green-200' : 'bg-red-50 text-red-700 border border-red-200')
                    : 'bg-blue-50 text-blue-700 border border-blue-200'
                }`}>
                  {(phase === 'craving' || phase === 'decision') && (currentCraving ? `Morning: ü§§ Craving! Will you drink ${CONFIG.playerName0}?` : currentCraving === false ? `Morning: üòê No craving. Will you drink ${CONFIG.playerName0}?` : `Morning: Will you drink ${CONFIG.playerName0}?`)}
                  {phase === 'outcome' && currentOutcome === null && (currentDrank ? `You chose to drink ${CONFIG.playerName0} ${CONFIG.playerIcon0}` : 'You chose to skip ‚äò')}
                  {phase === 'outcome' && currentOutcome !== null && (currentOutcome ? `Later this day: ${capitalize(CONFIG.playerName2Pos)}! üòä` : `Later this day: ${capitalize(CONFIG.playerName2Neg)} üòî`)}
                </span>
              </div>

              <div className="absolute top-4 left-4 bg-white rounded-xl px-4 py-2 border border-gray-200 shadow-sm">
                <div className="text-gray-700 font-medium text-sm mb-1">Monday</div>
                <div className="flex items-center gap-3">
                  <div>
                    <span className="text-gray-400 text-sm">Week</span>
                    <div className="text-gray-900 text-2xl font-bold">{currentRound}</div>
                  </div>
                  <div className="text-gray-300 text-xl">/</div>
                  <div className="text-gray-400 text-lg">{CONFIG.totalRounds}</div>
                </div>
                <div className="w-20 h-2 bg-gray-200 rounded-full mt-2 overflow-hidden">
                  <div
                    className="h-full bg-gradient-to-r from-blue-400 to-blue-600 transition-all duration-300"
                    style={{ width: `${(currentRound / CONFIG.totalRounds) * 100}%` }}
                  />
                </div>
              </div>

              <div className="flex items-center justify-center gap-8 mt-16">
                <CravingIndicator craving={currentCraving} />
                <div className="text-gray-400 text-2xl">‚Üí</div>
                <DrinkDecisionPanel
                  onChoice={handleChoice}
                  disabled={phase !== 'decision'}
                  craving={currentCraving}
                  selected={currentDrank}
                  showCoinAnimation={showCoinAnimation}
                  coinFading={coinFading}
                />
                <div className="text-gray-400 text-2xl">‚Üí</div>
                <OutcomeIndicator noHeadache={currentOutcome} />
              </div>
            </div>

            <div className="grid grid-cols-3 gap-4 items-stretch">
              <CravingStatsPanel stats={stats} currentCraving={currentCraving} />
              <DrinkHeadacheCorrelation stats={stats} currentDrank={currentDrank} />
              <ScrollableHistory history={history} />
            </div>
          </div>
        </div>
      );
    }

    // Render the app
    ReactDOM.createRoot(document.getElementById('root')).render(<CravingExperiment />);
  </script>
</body>
</html>
