<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Button Game</title>
<style>
body {
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    margin: 0;
    padding: 0;
    background: white;
    overflow-x: hidden;
}

.game-container {
    display: flex;
    max-width: 650px;
    margin: 20px auto;
    gap: 15px;
    align-items: flex-start;
}

.panels-section {
    flex: 1;
    min-width: 500px;
}

.stats-section {
    width: 300px;
    flex-shrink: 0;
    margin-top: 50px;
}

.game-title {
    font-size: 18px;
    text-align: center;
    padding: 10px 0;
    margin-bottom: 10px;
    color: #333;
    font-weight: bold;
}

.panel {
    position: relative;
    width: 100%;
    min-height: 120px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    margin-bottom: 10px;
    border: 1px solid black;
    padding: 15px;
}

.panel-header {
    position: absolute;
    top: 8px;
    left: 12px;
    display: flex;
    align-items: center;
    gap: 6px;
}

.panel-icon {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: 2px solid #fff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

.panel-name {
    font-weight: bold;
    font-size: 20px;
    color: #333;
}

.text {
    text-align: center;
    font-size: 16px;
    padding: 8px;
    color: #333;
    margin-top: 0;
}

.choice-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: 8px;
    width: 100%;
    margin-top: 20px;
}

.choice-row {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 8px 12px;
    background: #f8f9fa;
    border-radius: 4px;
    border: 1px solid #dee2e6;
    transition: all 0.3s ease;
}

.choice-row.hidden {
    opacity: 0.3;
    pointer-events: none;
    background: #e9ecef;
}

.choice-row.current {
    border: 2px solid #007bff;
    background: #e3f2fd;
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.4); }
    70% { box-shadow: 0 0 0 10px rgba(0, 123, 255, 0); }
    100% { box-shadow: 0 0 0 0 rgba(0, 123, 255, 0); }
}

.choice-row.completed {
    border: 1px solid #dee2e6;
    background: #f8f9fa;
}

.choice-row.invalid {
    border: 2px solid #f8b4b4;
    background: #fdf2f2;
}

.choice-buttons {
    display: flex;
    gap: 8px;
}

.actionButton {
    padding: 6px 12px;
    font-size: 12px;
    cursor: pointer;
    border: none;
    color: white;
    border-radius: 4px;
    transition: background-color 0.3s, transform 0.2s;
    text-align: center;
}

.actionButton:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
}

.actionButton:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
}

.green { background-color: #4CAF50; }
.red { background-color: #f44336; }

.selected {
    outline: 3px solid #007bff;
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
}

.cost-amt {
    display: inline-block;
    font-weight: bold;
    color: #faeb7a;
}

.submit-container {
    margin-top: 15px;
    text-align: center;
}

.submit-button {
    padding: 10px 25px;
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    border: none;
    color: white;
    border-radius: 4px;
    background-color: #007bff;
    transition: background-color 0.3s, transform 0.2s;
}

.submit-button:hover {
    background-color: #0056b3;
    transform: translateY(-2px);
}

.submit-button:disabled {
    background-color: #6c757d;
    cursor: not-allowed;
    transform: none;
}

.validation-message {
    margin-top: 10px;
    padding: 10px;
    border-radius: 4px;
    text-align: center;
    font-size: 14px;
}

.validation-error {
    background: #fdf2f2;
    color: #9a3a3a;
    border: 1px solid #f8b4b4;
}

.validation-success {
    background: #d4edda;
    color: #155724;
    border: 1px solid #c3e6cb;
}

.progress-indicator {
    margin-top: 10px;
    text-align: center;
    font-size: 14px;
    color: #666;
}

.lock-icon {
    position: absolute;
    top: 5px;
    right: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0.8;
    z-index: 10;
}

.stats-container {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border-radius: 10px;
    padding: 15px;
    box-shadow: 0 3px 10px rgba(0,0,0,0.15);
    border: 1px solid rgba(0,0,0,0.1);
}

.stat-box {
    background: white;
    border-radius: 6px;
    padding: 12px;
    margin-bottom: 15px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.1);
    font-size: 14px;
}

.stat-box:last-child {
    margin-bottom: 30px;
}

.insufficient-data {
    text-align: center;
    color: #999;
    font-style: italic;
    font-size: 12px;
}

.stat-1 { margin-top: 50px; }
.stat-2 { margin-top: 20px; }

.results-panel {
    background: #e8f5e8;
    border: 1px solid #4CAF50;
}

.results-text {
    color: #2e7d32;
    font-weight: bold;
}
</style>
</head>
<body>

<div id="gameContainer" class="game-container" style="display: none;">
    <div class="panels-section">
        <div id="gameTitle" class="game-title">Make your choices for each cost scenario</div>
        
        <div id="panelAchoice" class="panel">
            <div class="panel-header">
                <div class="panel-name">You</div>
            </div>
            <div id="actionPrompt" class="text">Press your button? (You must switch from No to Yes exactly once)</div>
            
            <div id="progressIndicator" class="progress-indicator">Decision 1 of 7</div>
            
            <div id="choiceGrid" class="choice-grid">
                <!-- Choice rows will be generated here -->
            </div>
            
            <div id="validationMessage" class="validation-message" style="display: none;"></div>
            
            <div class="submit-container">
                <button id="submitChoices" class="submit-button" disabled>Submit All Choices</button>
            </div>
        </div>
        
        <div id="panelXinfo" class="panel">
            <div class="panel-header">
                <img src="https://via.placeholder.com/40/4CAF50/FFFFFF?text=P1" class="panel-icon" alt="Player">
                <div class="panel-name">Player A</div>
            </div>
            <div id="riskText" class="text">(waiting for your choices)</div>
        </div>
        
        <div id="panelYinfo" class="panel">
            <div class="panel-header">
                <img src="https://via.placeholder.com/40/2196F3/FFFFFF?text=P2" class="panel-icon" alt="Player">
                <div class="panel-name">Player B</div>
            </div>
            <div id="resultText" class="text">(waiting for your choices)</div>
        </div>
    </div>
    
    <div class="stats-section">
        <div class="stats-container">
            <div class="stat-box stat-1">
                <div class="insufficient-data">Sequential Choice Mode</div>
            </div>
            
            <div class="stat-box stat-2">
                <div class="insufficient-data">Focus on causal relationships<br><br>
                <strong>Rule:</strong> You must switch from No to Yes exactly once as costs decrease<br><br>
                <strong>Current:</strong> A â†’ Y<br>
                You choose A<br>
                A determines Y<br>
                X is forced</div>
            </div>
        </div>
    </div>
</div>

<script>
/* ===================== CONFIGURATION ===================== */
let gameConfig = {
    yBonus: 1.0,
    pY: 0.5,
    playerName1: "Player A",
    playerName2: "Player B", 
    playerPronoun1: "their",
    playerPronoun2: "their",
    noise: 0.1,
    causal: 1,
    playerIcon1: "https://via.placeholder.com/40/4CAF50/FFFFFF?text=P1",
    playerIcon2: "https://via.placeholder.com/40/2196F3/FFFFFF?text=P2",
    currentHue: 200,
    causalElicitType: "AX", // Can be "AX", "AY", or "XY"
    exoButton: 1,
    costArray: [2, 1, 0.5, 0, -0.5, -1, -2],
    
};

let participantId = null;

/* ========================= GAME STATE ========================= */
let choices = new Array(7).fill(null); // Store player choices
let currentChoiceIndex = 0; // Track which choice is currently active
let gameStartTime = Date.now();

/* ========================== DOM ELEMENTS ========================== */
const choiceGrid = document.getElementById("choiceGrid");
const submitButton = document.getElementById("submitChoices");
const panelXinfo = document.getElementById("panelXinfo");
const panelYinfo = document.getElementById("panelYinfo");
const panelAchoice = document.getElementById("panelAchoice");
const resultText = document.getElementById("resultText");
const riskText = document.getElementById("riskText");
const gameTitle = document.getElementById("gameTitle");
const actionPrompt = document.getElementById("actionPrompt");
const validationMessage = document.getElementById("validationMessage");
const progressIndicator = document.getElementById("progressIndicator");

/* ===================== HELPER FUNCTIONS ===================== */
function createLockIcon() {
    const lockSvg = document.createElement('div');
    lockSvg.className = 'lock-icon';
    lockSvg.innerHTML = `
        <svg class="svg-icon" style="width: 2.5em; height: 2.5em; vertical-align: middle; overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
            <path d="M824.888889 426.666667v-85.333334c0-173.511111-139.377778-312.888889-312.888889-312.888889S199.111111 167.822222 199.111111 341.333333v85.333334H85.333333v455.111111h853.333334V426.666667h-113.777778z m-284.444445 219.022222V739.555556h-56.888888v-93.866667c-17.066667-8.533333-28.444444-28.444444-28.444445-48.355556 0-31.288889 25.6-56.888889 56.888889-56.888889s56.888889 25.6 56.888889 56.888889c0 19.911111-11.377778 39.822222-28.444445 48.355556zM512 426.666667h-199.111111v-85.333334c0-110.933333 88.177778-199.111111 199.111111-199.111111s199.111111 88.177778 199.111111 199.111111v85.333334h-199.111111z" fill="" />
        </svg>
    `;
    return lockSvg;
}

function updateProgressIndicator() {
    const completedChoices = choices.filter(choice => choice !== null).length;
    const totalChoices = gameConfig.costArray.length;
    const displayNumber = Math.min(completedChoices + 1, totalChoices);
    progressIndicator.textContent = `Decision ${displayNumber} of ${totalChoices}`;
}

function updateRowStates() {
    console.log('Updating row states, currentChoiceIndex:', currentChoiceIndex);
    
    document.querySelectorAll('.choice-row').forEach((row, index) => {
        // Clear all state classes
        row.classList.remove('current', 'completed', 'hidden');
        
        const buttons = row.querySelectorAll('.actionButton');
        
        if (index < currentChoiceIndex) {
            // Completed rows
            row.classList.add('completed');
            buttons.forEach(btn => btn.disabled = false); // Keep enabled for potential editing
        } else if (index === currentChoiceIndex) {
            // Current active row
            row.classList.add('current');
            buttons.forEach(btn => btn.disabled = false);
            console.log('Set row', index, 'as current');
        } else {
            // Future rows
            row.classList.add('hidden');
            buttons.forEach(btn => btn.disabled = true);
        }
    });
}

function checkForInvalidSwitch() {
    // Look for any "Yes" followed by "No" in the current choices
    for (let i = 1; i <= currentChoiceIndex; i++) {
        if (choices[i-1] === 'y' && choices[i] === 'n') {
            return true;
        }
    }
    return false;
}

function highlightInvalidSwitch() {
    // Clear previous highlighting
    document.querySelectorAll('.choice-row').forEach(row => {
        row.classList.remove('invalid');
    });
    
    // Find and highlight instances where "Yes" is followed by "No"
    for (let i = 1; i <= currentChoiceIndex; i++) {
        if (choices[i-1] === 'y' && choices[i] === 'n') {
            document.querySelector(`[data-choice="${i-1}"]`).classList.add('invalid');
            document.querySelector(`[data-choice="${i}"]`).classList.add('invalid');
        }
    }
}

function showInvalidSwitchWarning() {
    validationMessage.textContent = "Warning: You switched from 'Yes' back to 'No'. This creates an invalid pattern. You can change your previous choices by clicking on them, or continue with your current choices.";
    validationMessage.className = 'validation-message validation-error';
    validationMessage.style.display = 'block';
    highlightInvalidSwitch();
}

function hideValidationMessage() {
    validationMessage.style.display = 'none';
    // Clear any previous invalid highlighting
    document.querySelectorAll('.choice-row').forEach(row => {
        row.classList.remove('invalid');
    });
}

function updateButtonSelection(choiceIndex, decision) {
    // Update button appearance
    const row = document.querySelector(`[data-choice="${choiceIndex}"]`);
    const yesBtn = row.querySelector('.yes-btn');
    const noBtn = row.querySelector('.no-btn');
    
    // Reset both buttons
    yesBtn.classList.remove('selected');
    noBtn.classList.remove('selected');
    
    // Highlight selected button
    if (decision === 'y') {
        yesBtn.classList.add('selected');
    } else {
        noBtn.classList.add('selected');
    }
}

function sendChoiceData(choiceIndex, decision, hasInvalidSwitch, isEdit = false) {
    sendDataToQualtrics('CHOICE_DATA', {
        choiceIndex: choiceIndex,
        cost: gameConfig.costArray[choiceIndex],
        decision: decision,
        timestamp: Date.now() - gameStartTime,
        hasInvalidSwitch: hasInvalidSwitch,
        isEdit: isEdit
    });
}

function clearLockIcons() {
    const existingLocks = document.querySelectorAll('.lock-icon');
    existingLocks.forEach(lock => lock.remove());
}

/* =============== QUALTRICS COMMUNICATION =============== */
function sendDataToQualtrics(dataType, data) {
    console.log(`Qualtrics data [${dataType}]:`, data);
    if (window.parent !== window) {
        window.parent.postMessage({
            type: 'GAME_DATA',
            dataType: dataType,
            data: data,
            participantId: participantId,
            timestamp: new Date().toISOString()
        }, '*');
    }
}

window.addEventListener('message', function(event) {
    if (event.data.type === 'INIT') {
        participantId = event.data.participantId;
        if (event.data.gameConfig) {
            Object.assign(gameConfig, event.data.gameConfig);
            applyGameConfiguration();
        }
    }
});

function applyGameConfiguration() {
    console.log("Applying game configuration");
    
    document.body.style.background = `hsl(${gameConfig.currentHue} 70% 85%)`;
    
    const playerName1El = document.querySelector('#panelXinfo .panel-name');
    const playerName2El = document.querySelector('#panelYinfo .panel-name');
    const playerIcon1El = document.querySelector('#panelXinfo .panel-icon');
    const playerIcon2El = document.querySelector('#panelYinfo .panel-icon');
    
    if (playerName1El) playerName1El.textContent = gameConfig.playerName1;
    if (playerName2El) playerName2El.textContent = gameConfig.playerName2;
    if (playerIcon1El) playerIcon1El.src = gameConfig.playerIcon1;
    if (playerIcon2El) playerIcon2El.src = gameConfig.playerIcon2;
    
    // Apply bonus indicators based on treatment
    if (gameConfig.causalElicitType === "AX") {
        if (playerName1El) playerName1El.textContent += " (determines your bonus)";
    } else if (gameConfig.causalElicitType === "AY" || gameConfig.causalElicitType === "XY") {
        if (playerName2El) playerName2El.textContent += " (determines your bonus)";
    }
    
    // MOVE ELEMENTS BASED ON TREATMENT - Always reset first
    // First, ensure all elements are back in their original positions
    const originalPanel = panelAchoice;
    const elementsToMove = [progressIndicator, choiceGrid, validationMessage, document.querySelector('.submit-container')];
    
    elementsToMove.forEach(element => {
        if (element && element.parentNode !== originalPanel) {
            element.parentNode.removeChild(element);
            originalPanel.appendChild(element);
        }
    });
    
    // Now move to correct panel based on treatment
    if (gameConfig.causalElicitType === "XY") {
        // Move elements to Player A panel for XY treatment
        elementsToMove.forEach(element => {
            if (element && element.parentNode === originalPanel) {
                element.parentNode.removeChild(element);
                panelXinfo.appendChild(element);
            }
        });
        
        // Update Player A panel header
        if (playerName1El) {
            playerName1El.textContent = gameConfig.playerName1;
        }
    }
    
    // Add lock icons for forced players
    clearLockIcons();
    if (gameConfig.causalElicitType === 'AY') {
        const lockIcon = createLockIcon();
        panelXinfo.appendChild(lockIcon);
    }
    if (gameConfig.causalElicitType === 'AX') {
        const lockIcon = createLockIcon();
        panelYinfo.appendChild(lockIcon);
    }
    if (gameConfig.causalElicitType === 'XY') {
        const lockIcon = createLockIcon();
        panelAchoice.appendChild(lockIcon);
    }
    
    // Update initial panel messages and backgrounds
    const messages = getMessages();
    riskText.innerHTML = messages.xMessage;
    resultText.innerHTML = messages.yMessage;
    panelXinfo.style.backgroundColor = messages.xBackgroundColor;
    panelYinfo.style.backgroundColor = messages.yBackgroundColor;
    
    // Update action prompt based on treatment
    if (gameConfig.causalElicitType === "XY") {
        if (gameConfig.exoButton == 1) {
            actionPrompt.innerHTML = "You are forced to press your button";
            panelAchoice.style.backgroundColor = "lightgreen";
        } else {
            actionPrompt.innerHTML = "You are forced NOT to press your button";
            panelAchoice.style.backgroundColor = "lightcoral";
        }
        // Set Player A background to white for XY treatment
        panelXinfo.style.backgroundColor = "white";
    } else {
        actionPrompt.innerHTML = "Press your button?";
        panelAchoice.style.backgroundColor = "white";
    }
}

/* ===================== CHOICE HANDLING ===================== */
function handleChoice(choiceIndex, decision) {
    console.log('handleChoice called:', choiceIndex, decision, 'currentChoiceIndex:', currentChoiceIndex);
    
    // Allow editing any choice if all choices are complete
    if (currentChoiceIndex >= choices.length) {
        // All choices complete - allow editing any choice
        choices[choiceIndex] = decision;
        updateButtonSelection(choiceIndex, decision);
        
        // Check for invalid switching and update warning
        const hasInvalidSwitch = checkForInvalidSwitch();
        if (hasInvalidSwitch) {
            showInvalidSwitchWarning();
        } else {
            hideValidationMessage();
        }
        
        sendChoiceData(choiceIndex, decision, hasInvalidSwitch, true);
        return; // Don't proceed to next choice when editing
    }
    
    // Allow editing previous choices if there's an invalid switch or if it's the current choice
    if (choiceIndex < currentChoiceIndex) {
        // This is a previous choice - allow editing
        choices[choiceIndex] = decision;
        updateButtonSelection(choiceIndex, decision);
        
        // Check for invalid switching and show warning
        const hasInvalidSwitch = checkForInvalidSwitch();
        if (hasInvalidSwitch) {
            showInvalidSwitchWarning();
        } else {
            hideValidationMessage();
        }
        
        sendChoiceData(choiceIndex, decision, hasInvalidSwitch, true);
        return; // Don't proceed to next choice when editing previous choices
    }
    
    // Normal sequential choice handling for current choice
    if (choiceIndex !== currentChoiceIndex) {
        console.log('Ignoring click - not current choice');
        return; // Ignore clicks on future choices during sequential mode
    }
    
    choices[choiceIndex] = decision;
    console.log('Choice recorded:', choices);
    
    updateButtonSelection(choiceIndex, decision);
    
    // Check for invalid switching and show warning
    const hasInvalidSwitch = checkForInvalidSwitch();
    if (hasInvalidSwitch) {
        showInvalidSwitchWarning();
    } else {
        hideValidationMessage();
    }
    
    sendChoiceData(choiceIndex, decision, hasInvalidSwitch);
    
    // Move to next choice after a short delay
    setTimeout(() => {
        currentChoiceIndex++;
        console.log('Moving to next choice, new currentChoiceIndex:', currentChoiceIndex);
        updateProgressIndicator();
        updateRowStates();
        
        // If all choices are made, enable submit button
        if (currentChoiceIndex >= choices.length) {
            submitButton.disabled = false;
            
            // Only show warning if there's an invalid switch, otherwise hide message
            const hasInvalidSwitch = checkForInvalidSwitch();
            if (hasInvalidSwitch) {
                showInvalidSwitchWarning();
            } else {
                hideValidationMessage();
            }
            
            // Make all rows editable
            document.querySelectorAll('.choice-row').forEach((row, index) => {
                row.classList.remove('current', 'hidden');
                row.classList.add('completed');
                const buttons = row.querySelectorAll('.actionButton');
                buttons.forEach(btn => btn.disabled = false);
            });
        }
    }, 500);
}

function handleKeyPress(event) {
    // Only handle y/n keys when game is active
    if (document.getElementById("gameContainer").style.display === "none") {
        return; // Game not started yet
    }
    
    const key = event.key.toLowerCase();
    
    if (key === 'y' || key === 'n') {
        event.preventDefault(); // Prevent default browser behavior
        
        const decision = key === 'y' ? 'y' : 'n';
        
        // If all choices are complete, can't use keyboard for editing (too ambiguous which choice to edit)
        if (currentChoiceIndex >= choices.length) {
            return;
        }
        
        // Handle current choice with keyboard
        if (currentChoiceIndex < choices.length) {
            handleChoice(currentChoiceIndex, decision);
        }
    }
}

function createChoiceRow(index) {
    const cost = gameConfig.costArray[index];
    const row = document.createElement('div');
    row.className = 'choice-row';
    row.setAttribute('data-choice', index);
    
    let yesText, noText;
    
    if (cost > 0) {
        yesText = `Yes (<span class="cost-amt">cost $${cost.toFixed(1)}</span>)`;
        noText = `No (<span class="cost-amt">free</span>)`;
    } else if (cost === 0) {
        yesText = `Yes (<span class="cost-amt">free</span>)`;
        noText = `No (<span class="cost-amt">free</span>)`;
    } else {
        yesText = `Yes (<span class="cost-amt">free</span>)`;
        noText = `No (<span class="cost-amt">cost $${Math.abs(cost).toFixed(1)}</span>)`;
    }
    
    row.innerHTML = `
        <div class="choice-buttons">
            <button class="actionButton red no-btn" disabled>${noText}</button>
            <button class="actionButton green yes-btn" disabled>${yesText}</button>
        </div>
    `;
    
    // Add event listeners
    const yesBtn = row.querySelector('.yes-btn');
    const noBtn = row.querySelector('.no-btn');
    
    yesBtn.addEventListener('click', () => {
        console.log('Yes button clicked for choice', index);
        handleChoice(index, 'y');
    });
    
    noBtn.addEventListener('click', () => {
        console.log('No button clicked for choice', index);
        handleChoice(index, 'n');
    });
    
    return row;
}

function submitAllChoices() {
    submitButton.disabled = true;
    submitButton.textContent = "Processing...";
    
    // Randomly select one choice to implement
    const selectedChoiceIndex = Math.floor(Math.random() * 7);
    const selectedChoice = choices[selectedChoiceIndex];
    const selectedCost = gameConfig.costArray[selectedChoiceIndex];
    
    // Calculate game outcome based on selected choice
    let A, X, Y, payment;
    
    if (gameConfig.causalElicitType === "XY") {
        A = gameConfig.exoButton;
        X = selectedChoice === 'y' ? 1 : 0;
        if (gameConfig.causal === 0) {
            Y = Math.random() < gameConfig.pY ? 1 : 0;
        } else {
            const pY = [gameConfig.noise, 1-gameConfig.noise];
            Y = Math.random() < pY[X] ? 1 : 0;
        }
        
        if (selectedCost >= 0) {
            payment = -X * selectedCost + gameConfig.yBonus * Y;
        } else {
            payment = (1-X) * selectedCost + gameConfig.yBonus * Y;
        }
    } else if (gameConfig.causalElicitType === "AX") {
        A = selectedChoice === 'y' ? 1 : 0;
        Y = gameConfig.exoButton;
        if (gameConfig.causal === 0) {
            const pX = [gameConfig.noise, 1-gameConfig.noise, 1-gameConfig.noise, 1-gameConfig.noise];
            X = Math.random() < pX[A*2 + Y] ? 1 : 0;
        } else {
            const pX = [gameConfig.noise, 1-gameConfig.noise];
            X = Math.random() < pX[A] ? 1 : 0;
        }
        
        if (selectedCost >= 0) {
            payment = -A * selectedCost + gameConfig.yBonus * X;
        } else {
            payment = (1-A) * selectedCost + gameConfig.yBonus * X;
        }
    } else if (gameConfig.causalElicitType === "AY") {
        A = selectedChoice === 'y' ? 1 : 0;
        X = gameConfig.exoButton;
        if (gameConfig.causal === 0) {
            Y = Math.random() < gameConfig.pY ? 1 : 0;
        } else {
            const pY = [gameConfig.noise, 1-gameConfig.noise];
            Y = Math.random() < pY[X] ? 1 : 0;
        }
        
        if (selectedCost >= 0) {
            payment = -A * selectedCost + gameConfig.yBonus * Y;
        } else {
            payment = (1-A) * selectedCost + gameConfig.yBonus * Y;
        }
    }
    
    // Send final data
    sendDataToQualtrics('FINAL_DATA', {
        allChoices: choices,
        costs: gameConfig.costArray,
        selectedChoiceIndex: selectedChoiceIndex,
        selectedChoice: selectedChoice,
        selectedCost: selectedCost,
        playerA: A,
        playerX: X,
        playerY: Y,
        payment: payment,
        totalTime: (Date.now() - gameStartTime) / 1000,
        config: gameConfig,
        switchingPoint: choices.indexOf('y')
    });
    
    // Show results
    showResults(selectedChoiceIndex, A, X, Y, payment);
}

function getMessages() {
    let xMessage = '';
    let yMessage = '';
    let xBackgroundColor = 'white';
    let yBackgroundColor = 'white';
    
    if (gameConfig.causalElicitType === "AX") {
        xMessage = `${gameConfig.playerName1} will decide based on your choice`;
        xBackgroundColor = 'lightgray';
        
        if (gameConfig.exoButton == 1) {
            yMessage = `${gameConfig.playerName2} is forced to press ${gameConfig.playerPronoun2} button`;
            yBackgroundColor = "lightgreen";
        } else {
            yMessage = `${gameConfig.playerName2} is forced NOT to press ${gameConfig.playerPronoun2} button`;
            yBackgroundColor = "lightcoral";
        }
    } else if (gameConfig.causalElicitType === "AY") {
        if (gameConfig.exoButton == 1) {
            xMessage = `${gameConfig.playerName1} is forced to press ${gameConfig.playerPronoun1} button`;
            xBackgroundColor = "lightgreen";
        } else {
            xMessage = `${gameConfig.playerName1} is forced NOT to press ${gameConfig.playerPronoun1} button`;
            xBackgroundColor = "lightcoral";
        }
        
        yMessage = `${gameConfig.playerName2} will decide based on ${gameConfig.playerName1}'s forced choice`;
        yBackgroundColor = 'lightgray';
    } else if (gameConfig.causalElicitType === "XY") {
        xMessage = `Press ${gameConfig.playerName1}'s button for them`;
        xBackgroundColor = 'lightgray';
        
        yMessage = `${gameConfig.playerName2} will decide based on ${gameConfig.playerName1}'s choice`;
        yBackgroundColor = 'lightgray';
    }
    
    return { xMessage, yMessage, xBackgroundColor, yBackgroundColor };
}

function showResults(selectedChoiceIndex, A, X, Y, payment) {
    // Update game state displays
    gameTitle.textContent = `Results`;
    actionPrompt.innerHTML = `One of the rows is randomly selected to be implemented`;
    
    // Hide choice grid, validation message, progress indicator and submit button
    choiceGrid.style.display = 'none';
    validationMessage.style.display = 'none';
    progressIndicator.style.display = 'none';
    submitButton.style.display = 'none';
    
    // Show only that Player A has made their decision, without revealing the outcome
    if (gameConfig.causalElicitType === "AX") {
        riskText.innerHTML = `${gameConfig.playerName1} has made ${gameConfig.playerPronoun1} decision`;
        panelXinfo.style.backgroundColor = "lightgray";
        
        if (gameConfig.exoButton == 1) {
            resultText.innerHTML = `${gameConfig.playerName2} is forced to press ${gameConfig.playerPronoun2} button`;
            panelYinfo.style.backgroundColor = "lightgreen";
        } else {
            resultText.innerHTML = `${gameConfig.playerName2} is forced NOT to press ${gameConfig.playerPronoun2} button`;
            panelYinfo.style.backgroundColor = "lightcoral";
        }
    } else if (gameConfig.causalElicitType === "AY") {
        if (gameConfig.exoButton == 1) {
            riskText.innerHTML = `${gameConfig.playerName1} is forced to press ${gameConfig.playerPronoun1} button`;
            panelXinfo.style.backgroundColor = "lightgreen";
        } else {
            riskText.innerHTML = `${gameConfig.playerName1} is forced NOT to press ${gameConfig.playerPronoun1} button`;
            panelXinfo.style.backgroundColor = "lightcoral";
        }
        
        resultText.innerHTML = `${gameConfig.playerName2} has made ${gameConfig.playerPronoun2} decision`;
        panelYinfo.style.backgroundColor = "lightgray";
    } else if (gameConfig.causalElicitType === "XY") {
        riskText.innerHTML = `${gameConfig.playerName1} has made ${gameConfig.playerPronoun1} decision`;
        panelXinfo.style.backgroundColor = "lightgray";
        
        resultText.innerHTML = `${gameConfig.playerName2} has made ${gameConfig.playerPronoun2} decision`;
        panelYinfo.style.backgroundColor = "lightgray";
    }
    
    // Change panel styling to show completion
    panelAchoice.classList.add('results-panel');
    actionPrompt.classList.add('results-text');
    
    sendDataToQualtrics('GAME_COMPLETE', { completed: true });
}

/* ===================== INITIALIZE GAME ===================== */
function initializeGame() {
    console.log("Initializing sequential choice game");
    
    // Show the game container
    document.getElementById("gameContainer").style.display = "flex";
    
    // Create choice rows first
    gameConfig.costArray.forEach((cost, index) => {
        const row = createChoiceRow(index);
        choiceGrid.appendChild(row);
    });
    
    // Apply configuration (this will move elements to correct panels)
    applyGameConfiguration();
    
    // Initialize row states - only first row is active
    updateRowStates();
    updateProgressIndicator();
    
    // Add submit button listener
    submitButton.addEventListener('click', submitAllChoices);
    
    // Add keyboard event listener
    document.addEventListener('keydown', handleKeyPress);
    
    sendDataToQualtrics('GAME_START', { started: true });
}

// Wait 3 seconds before starting the game
setTimeout(initializeGame, 3000);

</script>
</body>
</html>