<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Button Game</title>
<style>
body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    background: white;
}

.game-container {
    display: flex;
    max-width: 650px;
    margin: 20px auto;
    gap: 15px;
    align-items: flex-start;
    justify-content: center;
}

.panels-section {
    flex: 1;
    min-width: 500px;
    max-width: 500px;
    margin: 20px auto;
}

.roundDisplay {
    font-size: 18px;
    text-align: center;
    padding: 10px 0;
    margin-bottom: 10px;
    color: #333;
    font-weight: bold;
}

.panel {
    position: relative;
    width: 100%;
    min-height: 120px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    margin-bottom: 10px;
    border: 1px solid black;
    padding: 20px;
    box-sizing: border-box;
}

.panel-header {
    position: absolute;
    top: 8px;
    left: 12px;
    display: flex;
    align-items: center;
    gap: 6px;
}

.panel-icon {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: 2px solid #fff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

.panel-name {
    font-weight: bold;
    font-size: 20px;
    color: #333;
}

.text {
    text-align: center;
    font-size: 18px;
    padding: 8px;
    color: #333;
    margin-top: 20px;
}

.button-container {
    display: flex;
    gap: 10px;
    justify-content: center;
    align-items: center;
}

.actionButton {
    padding: 8px 16px;
    margin: 0;
    font-size: 16px;
    cursor: pointer;
    border: none;
    color: white;
    border-radius: 4px;
    transition: background-color 0.3s, transform 0.2s;
    width: 150px;
    text-align: center;
}

.actionButton:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
}

.actionButton:hover.grayed-out {
    transform: none;
    box-shadow: none;
}

.green { background-color: #4CAF50; }
.red { background-color: #f44336; }
.grayed-out { 
    background-color: #cccccc !important; 
    color: #666666 !important; 
    cursor: not-allowed !important;
}
.hidden { display: none; }

.flash {
    outline: 3px solid orange;
    transition: outline 0.2s ease;
}

/* Decision phase styles */
.decision-content {
    display: none;
    width: 100%;
    flex-direction: column;
    align-items: center;
}

.decision-content.active {
    display: flex;
}

.decision-title {
    font-size: 20px;
    text-align: center;
    margin-top: 20px;
    color: #333;
    font-weight: bold;
}

.decision-instructions {
    text-align: center;
}

.choice-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: 8px;
    width: 100%;
    margin: 20px 0;
}

.choice-row {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 8px 12px;
    background: #f8f9fa;
    border-radius: 4px;
    border: 1px solid #dee2e6;
    transition: all 0.3s ease;
}

.choice-row.current {
    border: 2px solid #007bff;
    background: #e3f2fd;
}

.choice-row.completed {
    border: 1px solid #dee2e6;
    background: #f8f9fa;
}

.choice-row.invalid {
    border: 2px solid #f8b4b4;
    background: #fdf2f2;
}

.choice-row.hidden {
    display: none;
}

.choice-buttons {
    display: flex;
    flex-direction: row;
    gap: 6px;
    width: 100%;
    max-width: 380px;
}

.choice-button {
    padding: 6px 12px;
    font-size: 16px;
    cursor: pointer;
    border: none;
    color: white;
    border-radius: 4px;
    transition: background-color 0.3s, transform 0.2s;
    text-align: center;
    flex: 1;
    min-height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-sizing: border-box;
}

.choice-button:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
}

.choice-button.selected {
    outline: 5px solid black;
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
}

.cost-amt {
    display: inline-block;
    font-weight: bold;
    color: #faeb7a;
}

.submit-container {
    margin-top: 15px;
    margin-bottom: 15px;
    text-align: center;
}

.submit-button {
    padding: 10px 25px;
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    border: none;
    color: white;
    border-radius: 4px;
    background-color: #007bff;
    transition: background-color 0.3s, transform 0.2s;
}

.submit-button:hover {
    background-color: #0056b3;
    transform: translateY(-2px);
}

.submit-button:disabled {
    background-color: #6c757d;
    cursor: not-allowed;
    transform: none;
}

.validation-message {
    margin-top: 10px;
    padding: 10px;
    border-radius: 4px;
    text-align: center;
    font-size: 14px;
}

.validation-error {
    background: #fdf2f2;
    color: #9a3a3a;
    border: 1px solid #f8b4b4;
}

.progress-indicator {
    margin-top: 10px;
    text-align: center;
    font-size: 14px;
    color: #666;
}



</style>
</head>

<body>
    <div class="decision-title" style="display: none;">Make Your Decisions</div>
    <div class="decision-instructions" style="display: none;">
        Now you will make decisions for different costs. 
    </div>
    <div id="gameContainer" class="game-container" style="display: none;">
        <div class="panels-section">
            <div id="roundDisplay" class="roundDisplay"></div>
            
            <div id="panelAchoice" class="panel">
                <div class="panel-header">
                    <div class="panel-name">You</div>
                </div>
                <div id="actionPromptGame" class="text" style="display: none; margin-top: 0;">Press your button?</div>
                <div id="gameButtons" class="button-container" style="display: none;">
                    <button id="btnNo" class="actionButton red">No (free)</button>
                    <button id="btnYes" class="actionButton green">Yes (cost $0.25)</button>
                </div>
                
                <!-- Decision phase content -->
                <div id="decisionContent" class="decision-content">
                    <div id="actionPrompt" class="text">Press your button?</div>
                    <div id="progressIndicator" class="progress-indicator">Decision 1 of 9</div>
                    <div id="choiceGrid" class="choice-grid"></div>
                    <div id="validationMessage" class="validation-message" style="display: none;"></div>
                    
                    <div class="submit-container">
                        <button id="submitChoices" class="submit-button" disabled>Submit All Choices</button>
                    </div>
                </div>
            </div>
            
            <div id="panelXinfo" class="panel">
                <div class="panel-header">
                    <img src="https://via.placeholder.com/40/4CAF50/FFFFFF?text=P1" class="panel-icon" alt="Player">
                    <div class="panel-name">Player A</div>
                </div>
                <div id="resultText" class="text" style="display: none;"></div>
            </div>
        </div>
    </div>

<script>
    
/* ===================== DEFAULT CONFIGURATION ===================== */
let gameConfig = {
    nRounds: 3, 
    aCost: 0.25,
    yBonus: 2,
    playerName1: "Player A",
    playerPronoun1: "their",
    playerIcon1: "https://via.placeholder.com/40/4CAF50/FFFFFF?text=P1",
    currentHue: 200,
    pA: 0.5, 
    pX_A1: 0.8,
    pX_A0: 0.2,
    costArray: [4, 2, 1, 0.5, 0, -0.5, -1, -2, -4],
    increasingOrder: 0
};

let participantId = null;

/* ========================= GAME STATE ========================= */
let roundCounter = 0;
let X, A;
let history = [];
let roundTimes = [];
let roundStartTime = 0;
let resultDisplayed = false;

// Space bar delay state
let spaceBarEnabled = false;
let spaceBarTimeout = null;
let spacePressedEarly = false;

// Decision phase state
let choices = [];
let currentChoiceIndex = 0;
let gameStartTime = Date.now();

// Payment tracking
let payments = [];

/* ========================== DOM ELEMENTS ========================== */
const gameContainer = document.getElementById("gameContainer");
const btnNo = document.getElementById("btnNo");
const btnYes = document.getElementById("btnYes");
const panelXinfo = document.getElementById("panelXinfo");
const panelAchoice = document.getElementById("panelAchoice");
const resultText = document.getElementById("resultText");
const roundDisplay = document.getElementById("roundDisplay");
const gameButtons = document.getElementById("gameButtons");
const decisionContent = document.getElementById("decisionContent");
const actionPromptGame = document.getElementById("actionPromptGame");
const actionPrompt = document.getElementById("actionPrompt");

/* =============== QUALTRICS COMMUNICATION =============== */
function sendDataToQualtrics(dataType, data) {
    if (window.parent !== window) {
        window.parent.postMessage({
            type: 'GAME_DATA',
            dataType: dataType,
            data: data,
            participantId: participantId,
            timestamp: new Date().toISOString()
        }, '*');
    }
}

window.addEventListener('message', function(event) {
    if (event.data.type === 'INIT') {
        participantId = event.data.participantId;
        if (event.data.gameConfig) {
            Object.assign(gameConfig, event.data.gameConfig);
            applyGameConfiguration();
        }
    }
});

/* =============== HELPER FUNCTIONS =============== */

function applyGameConfiguration() {
    // Validate costArray
    if (!gameConfig.costArray || !Array.isArray(gameConfig.costArray) || gameConfig.costArray.length === 0) {
        console.error('Invalid or empty costArray provided. Using default.');
        gameConfig.costArray = [4, 2, 1, 0.5, 0, -0.5, -1, -2, -4];
    }
    
    btnYes.textContent = `Yes (cost $${gameConfig.aCost})`;
    
    const elements = {
        playerName1: document.querySelector('#panelXinfo .panel-name'),
        playerIcon1: document.querySelector('#panelXinfo .panel-icon')
    };
    
    if (elements.playerName1) elements.playerName1.textContent = gameConfig.playerName1;
    if (elements.playerIcon1) elements.playerIcon1.src = gameConfig.playerIcon1;
    
    document.body.style.background = `hsl(${gameConfig.currentHue} 70% 85%)`;
    
    // Initialize choices array based on costArray length
    choices = new Array(gameConfig.costArray.length).fill(null);
    
    // Initialize payments array (will grow as rounds are played)
    payments = [];
    
    // Update progress indicator with correct total
    updateProgressIndicator();
}

/* =============== SPACE BAR DELAY FUNCTIONS =============== */

function startSpaceBarDelay() {
    spaceBarEnabled = false;
    spacePressedEarly = false;
    
    // Clear any existing timeout
    if (spaceBarTimeout) {
        clearTimeout(spaceBarTimeout);
    }
    
    spaceBarTimeout = setTimeout(() => {
        spaceBarEnabled = true;
        
        // If space was pressed early, proceed now
        if (spacePressedEarly) {
            proceedToNextRound();
        }
    }, 500); // 0.5 second delay
}

function hideSpaceBarIndicator() {
    if (spaceBarTimeout) {
        clearTimeout(spaceBarTimeout);
        spaceBarTimeout = null;
    }
    spaceBarEnabled = false;
    spacePressedEarly = false;
}

/* ===================== GAME LOGIC ===================== */
function handleDecision(decision) {
    if (gameButtons.style.display === 'none') return;
    
    btnYes.disabled = btnNo.disabled = true;
    const selectedBtn = decision === 'y' ? btnYes : btnNo;
    selectedBtn.classList.add("flash");
    setTimeout(() => selectedBtn.classList.remove("flash"), 200);

    A = decision === 'y' ? 1 : 0;
    
    // Generate X based on A with the configured probabilities
    const pX = A === 1 ? gameConfig.pX_A1 : gameConfig.pX_A0;
    X = Math.random() < pX ? 1 : 0;

    // Calculate payment for this round
    let roundPayment = 0;
    if (A === 1) {
        roundPayment -= gameConfig.aCost; // Pay the cost if pressed Yes
    }
    if (X === 1) {
        roundPayment += gameConfig.yBonus; // Get bonus if other player pressed
    }
    payments.push(roundPayment);

    history.push([A, X]);
    
    resultDisplayed = false;

    setTimeout(() => {
        panelXinfo.style.backgroundColor = X ? "green" : "red";
        resultText.innerHTML = X
            ? `${gameConfig.playerName1} pressed ${gameConfig.playerPronoun1} button (bonus $${gameConfig.yBonus}).<br>(press "space" to continue)`
            : `${gameConfig.playerName1} did <u>not</u> press ${gameConfig.playerPronoun1} button (no bonus). <br>(press "space" to continue)`;
        resultDisplayed = true;
        
        // Start the space bar delay
        startSpaceBarDelay();
    }, 200);
}

function handleKeyPress(e) {
    if (e.key === ' ' && resultDisplayed) {
        if (spaceBarEnabled) {
            // Space bar is enabled, proceed immediately
            proceedToNextRound();
        } else {
            // Space bar not yet enabled, mark as pressed early
            spacePressedEarly = true;
        }
    }
}

function proceedToNextRound() {
    roundTimes.push((Date.now() - roundStartTime) / 1000);
    hideSpaceBarIndicator();
    
    if (roundCounter <= gameConfig.nRounds) {
        nextRound();
        resultDisplayed = false;
    }
}

function nextRound() {
    if (roundCounter < gameConfig.nRounds) {
        roundCounter++;
        roundDisplay.textContent = `Round ${roundCounter} of ${gameConfig.nRounds}`;
        
        // Hide entire panels during transition
        panelAchoice.style.display = "none";
        panelXinfo.style.display = "none";
        
        // Clear all panel content
        actionPromptGame.style.display = "none";
        actionPromptGame.innerHTML = "";
        gameButtons.style.display = "none";
        resultText.style.display = "none";
        resultText.innerHTML = "";
        panelXinfo.style.backgroundColor = "white";
        
        // Clear button states
        btnNo.classList.remove("grayed-out", "flash");
        btnYes.classList.remove("grayed-out", "flash");
        btnNo.disabled = false;
        btnYes.disabled = false;
        
        setTimeout(showActionPanels, 500);
    } else {
        // Game rounds complete, show decision phase
        showDecisionPhase();
    }
}

function showActionPanels() {
    // Show the panels first
    panelAchoice.style.display = "flex";
    panelXinfo.style.display = "flex";
    
    // Show game elements that were hidden initially
    actionPromptGame.style.display = "block";
    gameButtons.style.display = "flex";
    resultText.style.display = "block";
    
    // Reset panels
    panelXinfo.style.backgroundColor = "white";

    btnYes.disabled = btnNo.disabled = false;

    // Determine if player is forced to press a specific button
    const forcedChoice = Math.random() < gameConfig.pA;
    
    if (forcedChoice) {
        // Force "Yes"
        btnNo.classList.add("grayed-out");
        btnNo.disabled = true;
        btnYes.classList.remove("grayed-out");
        btnYes.disabled = false;
        actionPromptGame.innerHTML = "You must press \"Yes\" in this round. <br> Press your button? (Use your mouse)";
    } else {
        // Force "No"
        btnNo.classList.remove("grayed-out");
        btnNo.disabled = false;
        btnYes.classList.add("grayed-out");
        btnYes.disabled = true;
        actionPromptGame.innerHTML = "You must press \"No\" in this round. <br> Press your button? (Use your mouse)";
    }
    
    roundStartTime = Date.now();
}

/* =============== DECISION PHASE LOGIC =============== */

function showDecisionPhase() {
    // Hide space bar indicator when entering decision phase
    hideSpaceBarIndicator();
    
    // Show decision title and instructions at the top of the page
    document.querySelector('.decision-title').style.display = "block";
    document.querySelector('.decision-instructions').style.display = "block";
    
    // Hide game elements
    roundDisplay.style.display = "none";
    gameButtons.style.display = "none";
    actionPromptGame.style.display = "none";
    
    // Show decision content
    decisionContent.classList.add('active');
    
    // Show and update Panel X text
    resultText.style.display = "block";
    resultText.textContent = `${gameConfig.playerName1} will make ${gameConfig.playerPronoun1} decision.`;

    // change the background color of the panel to be white
    panelXinfo.style.backgroundColor = "white";

    // Create choice rows
    createChoiceRows();
    
    // Initialize decision phase
    currentChoiceIndex = 0;
    updateProgressIndicator();
    updateRowStates();
}

function createChoiceRows() {
    const choiceGrid = document.getElementById('choiceGrid');
    choiceGrid.innerHTML = ''; // Clear any existing content
    
    gameConfig.costArray.forEach((cost, index) => {
        const row = createChoiceRow(index, cost);
        choiceGrid.appendChild(row);
    });
}

function createChoiceRow(index, cost) {
    const row = document.createElement('div');
    row.className = 'choice-row';
    row.setAttribute('data-choice', index);
    
    let yesText, noText;
    
    if (gameConfig.increasingOrder === 1) {
        // When increasingOrder = 1, swap the cost assignments
        if (cost > 0) {
            yesText = `Yes (<span class="cost-amt">free</span>)`;
            noText = `No (<span class="cost-amt">cost $${cost.toFixed(1)}</span>)`;
        } else if (cost === 0) {
            yesText = `Yes (<span class="cost-amt">free</span>)`;
            noText = `No (<span class="cost-amt">free</span>)`;
        } else {
            yesText = `Yes (<span class="cost-amt">cost $${Math.abs(cost).toFixed(1)}</span>)`;
            noText = `No (<span class="cost-amt">free</span>)`;
        }
    } else {
        // When increasingOrder = 0, use original cost assignments
        if (cost > 0) {
            yesText = `Yes (<span class="cost-amt">cost $${cost.toFixed(1)}</span>)`;
            noText = `No (<span class="cost-amt">free</span>)`;
        } else if (cost === 0) {
            yesText = `Yes (<span class="cost-amt">free</span>)`;
            noText = `No (<span class="cost-amt">free</span>)`;
        } else {
            yesText = `Yes (<span class="cost-amt">free</span>)`;
            noText = `No (<span class="cost-amt">cost $${Math.abs(cost).toFixed(1)}</span>)`;
        }
    }
    
    row.innerHTML = `
        <div class="choice-buttons">
            <button class="choice-button red no-btn" disabled>${noText}</button>
            <button class="choice-button green yes-btn" disabled>${yesText}</button>
        </div>
    `;
    
    const yesBtn = row.querySelector('.yes-btn');
    const noBtn = row.querySelector('.no-btn');
    
    yesBtn.addEventListener('click', () => handleChoice(index, 'y'));
    noBtn.addEventListener('click', () => handleChoice(index, 'n'));
    
    return row;
}

function handleChoice(choiceIndex, decision) {
    if (currentChoiceIndex >= choices.length) {
        // Allow changing previous choices
        choices[choiceIndex] = decision;
        updateButtonSelection(choiceIndex, decision);
        
        const hasInvalidSwitch = checkForInvalidSwitch();
        if (hasInvalidSwitch) {
            showInvalidSwitchWarning();
        } else {
            hideValidationMessage();
        }
        return;
    }
    
    if (choiceIndex < currentChoiceIndex) {
        // Allow changing previous choices
        choices[choiceIndex] = decision;
        updateButtonSelection(choiceIndex, decision);
        
        const hasInvalidSwitch = checkForInvalidSwitch();
        if (hasInvalidSwitch) {
            showInvalidSwitchWarning();
        } else {
            hideValidationMessage();
        }
        return;
    }
    
    if (choiceIndex !== currentChoiceIndex) {
        return; // Ignore clicks on future choices
    }
    
    // Record the choice
    choices[choiceIndex] = decision;
    updateButtonSelection(choiceIndex, decision);
    
    const hasInvalidSwitch = checkForInvalidSwitch();
    if (hasInvalidSwitch) {
        showInvalidSwitchWarning();
    } else {
        hideValidationMessage();
    }
    
    // Move to next choice after a short delay
    setTimeout(() => {
        currentChoiceIndex++;
        updateProgressIndicator();
        updateRowStates();
        
        if (currentChoiceIndex >= choices.length) {
            // All choices made, enable submit button
            document.getElementById('submitChoices').disabled = false;
            
            // Make all rows available for editing
            const allRows = document.querySelectorAll('.choice-row');
            allRows.forEach((row, index) => {
                row.classList.remove('current', 'hidden');
                row.classList.add('completed');
                const buttons = row.querySelectorAll('.choice-button');
                buttons.forEach(btn => btn.disabled = false);
            });
        }
    }, 200);
}

function updateButtonSelection(choiceIndex, decision) {
    const row = document.querySelector(`[data-choice="${choiceIndex}"]`);
    const yesBtn = row.querySelector('.yes-btn');
    const noBtn = row.querySelector('.no-btn');
    
    yesBtn.classList.remove('selected');
    noBtn.classList.remove('selected');
    
    if (decision === 'y') {
        yesBtn.classList.add('selected');
    } else {
        noBtn.classList.add('selected');
    }
}

function updateProgressIndicator() {
    const completedChoices = choices.filter(choice => choice !== null).length;
    const totalChoices = gameConfig.costArray.length;
    const displayNumber = Math.min(completedChoices + 1, totalChoices);
    document.getElementById('progressIndicator').textContent = `Decision ${displayNumber} of ${totalChoices}`;
}

function updateRowStates() {
    const allRows = document.querySelectorAll('.choice-row');
    
    allRows.forEach((row, index) => {
        row.classList.remove('current', 'completed', 'hidden');
        
        const buttons = row.querySelectorAll('.choice-button');
        
        if (index < currentChoiceIndex) {
            row.classList.add('completed');
            buttons.forEach(btn => btn.disabled = false);
        } else if (index === currentChoiceIndex) {
            row.classList.add('current');
            buttons.forEach(btn => btn.disabled = false);
            
            // Auto-scroll to current choice
            setTimeout(() => {
                row.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center',
                    inline: 'nearest'
                });
            }, 100);
        } else {
            row.classList.add('hidden');
            buttons.forEach(btn => btn.disabled = true);
        }
    });
}

function checkForInvalidSwitch() {
    // Ensure we have valid choices and currentChoiceIndex
    if (!choices || choices.length === 0 || currentChoiceIndex < 1) {
        return false;
    }
    
    // Ensure we don't go beyond array bounds
    const maxIndex = Math.min(currentChoiceIndex, choices.length - 1);
    
    if (gameConfig.increasingOrder === 1) {
        // When increasingOrder = 1, check for switches from left to right (n to y)
        for (let i = 1; i <= maxIndex; i++) {
            if (choices[i-1] === 'n' && choices[i] === 'y') {
                return true;
            }
        }
    } else {
        // When increasingOrder = 0, check for switches from right to left (y to n)
        for (let i = 1; i <= maxIndex; i++) {
            if (choices[i-1] === 'y' && choices[i] === 'n') {
                return true;
            }
        }
    }
    return false;
}

function showInvalidSwitchWarning() {
    const validationMessage = document.getElementById('validationMessage');
    validationMessage.textContent = "Warning: You chose an option when it cost more, but not when it cost less. You can still change your earlier choices by clicking on them.";
    validationMessage.className = 'validation-message validation-error';
    validationMessage.style.display = 'block';
    
    // Clear any existing invalid highlighting
    document.querySelectorAll('.choice-row').forEach(row => {
        row.classList.remove('invalid');
    });
    
    // Ensure we have valid choices and currentChoiceIndex
    if (!choices || choices.length === 0 || currentChoiceIndex < 1) {
        return;
    }
    
    // Ensure we don't go beyond array bounds
    const maxIndex = Math.min(currentChoiceIndex, choices.length - 1);
    
    if (gameConfig.increasingOrder === 1) {
        // When increasingOrder = 1, highlight switches from left to right (n to y)
        for (let i = 1; i <= maxIndex; i++) {
            if (choices[i-1] === 'n' && choices[i] === 'y') {
                const prevRow = document.querySelector(`[data-choice="${i-1}"]`);
                const currentRow = document.querySelector(`[data-choice="${i}"]`);
                if (prevRow) prevRow.classList.add('invalid');
                if (currentRow) currentRow.classList.add('invalid');
            }
        }
    } else {
        // When increasingOrder = 0, highlight switches from right to left (y to n)
        for (let i = 1; i <= maxIndex; i++) {
            if (choices[i-1] === 'y' && choices[i] === 'n') {
                const prevRow = document.querySelector(`[data-choice="${i-1}"]`);
                const currentRow = document.querySelector(`[data-choice="${i}"]`);
                if (prevRow) prevRow.classList.add('invalid');
                if (currentRow) currentRow.classList.add('invalid');
            }
        }
    }
}

function hideValidationMessage() {
    const validationMessage = document.getElementById('validationMessage');
    validationMessage.style.display = 'none';
    document.querySelectorAll('.choice-row').forEach(row => {
        row.classList.remove('invalid');
    });
}

function submitAllChoices() {
    const submitButton = document.getElementById('submitChoices');
    submitButton.disabled = true;
    submitButton.textContent = "Choices Submitted";
    
    // Convert choices to binary array (0 for 'n', 1 for 'y')
    const choicesArray = choices.map(choice => choice === 'y' ? 1 : 0);
    
    // Calculate payments for multiple price list based on one realization
    const mplPayments = calculateMPLPayments();
    console.log('MPL Payments:', mplPayments);
    
    // Send data to Qualtrics
    sendDataToQualtrics('FINAL_DATA', {
        history: history,
        roundTimes: roundTimes,
        payments: payments,
        mplPayments: mplPayments,
        choices: choicesArray,
        totalTime: (Date.now() - gameStartTime) / 1000,
        config: gameConfig
    });
    
    sendDataToQualtrics('GAME_COMPLETE', { completed: true });
    
    console.log('=== FINAL DATA SENT TO QUALTRICS ===');
    console.log('Round History:', history);
    console.log('Round Payments:', payments);
    console.log('MPL Payments:', mplPayments);
    console.log('Decision Choices:', choicesArray);
    console.log('=====================================');
}

function calculateMPLPayments() {
    // Generate one realization of X for the multiple price list
    // Use the same logic as the game rounds but with varying costs
    const mplPayments = [];
    
    gameConfig.costArray.forEach((cost, index) => {
        const choice = choices[index]; // 'y' or 'n'
        const A = choice === 'y' ? 1 : 0;
        
        // Generate X based on A with the configured probabilities
        const pX = A === 1 ? gameConfig.pX_A1 : gameConfig.pX_A0;
        const X = Math.random() < pX ? 1 : 0;
        
        let payment = 0;
        
        if (choice === 'y') {
            // Player chose "Yes" - they pay the varying cost
            if (gameConfig.increasingOrder === 1) {
                // When increasingOrder = 1, cost assignments are swapped
                if (cost <= 0) {
                    payment -= Math.abs(cost); // Pay the cost for "Yes"
                }
                // If cost > 0, "Yes" is free (no cost)
            } else {
                // When increasingOrder = 0, original cost assignments
                if (cost > 0) {
                    payment -= cost; // Pay the cost for "Yes"
                }
                // If cost <= 0, "Yes" is free (no cost)
            }
        } else {
            // Player chose "No"
            if (gameConfig.increasingOrder === 1) {
                // When increasingOrder = 1, cost assignments are swapped
                if (cost > 0) {
                    payment -= cost; // Pay the cost for "No"
                }
                // If cost <= 0, "No" is free (no cost)
            } else {
                // When increasingOrder = 0, original cost assignments
                if (cost < 0) {
                    payment -= Math.abs(cost); // Pay the cost for "No"
                }
                // If cost >= 0, "No" is free (no cost)
            }
        }
        
        // Add actual bonus based on this realization
        if (X === 1) {
            payment += gameConfig.yBonus;
        }
        
        mplPayments.push(payment);
    });
    
    return mplPayments;
}

/* ===================== EVENT LISTENERS ===================== */
function handleButtonClick(decision) {
    handleDecision(decision);
}

btnYes.addEventListener("click", () => handleButtonClick('y'));
btnNo.addEventListener("click", () => handleButtonClick('n'));
document.addEventListener("keydown", handleKeyPress);

// Add submit button event listener
document.getElementById('submitChoices').addEventListener('click', submitAllChoices);

/* ===================== INITIALIZE GAME ===================== */
setTimeout(() => {
    applyGameConfiguration();
    gameContainer.style.display = "flex";
    sendDataToQualtrics('GAME_START', { started: true });
    nextRound();
}, 2000);

</script>
</body>
</html>